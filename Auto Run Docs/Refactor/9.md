# Refactor Task 9: src/main/history-manager.ts

## Summary

The `history-manager.ts` file (523 lines) is well-structured with a clean class-based design for per-session history storage. It handles migration from legacy single-file format to per-session files effectively. However, there is significant duplication with `src/cli/services/storage.ts` which reimplements similar history functionality, some methods are unused in production code, synchronous file operations could block the event loop, and there are minor type safety improvements needed.

## Dead Code

1. **`hasMigrated()` method (line 92-94)**: Public method never called from main process code. The migration check is done internally via `needsMigration()`. The CLI uses its own local `hasMigrated()` function.

2. **`getLegacyFilePath()` method (line 506-508)**: Marked as "for debugging/testing" but no test file exists for history-manager.ts. Only used internally by migration code, not externally.

3. **`getHistoryDir()` method (line 499-501)**: Marked as "for debugging/testing" but no test file exists. Not referenced externally.

4. **`ORPHANED_SESSION_ID` constant (shared/history.ts:13)**: Defined in shared module but only used in one IPC handler (`history.ts:107`). Not used by HistoryManager class itself.

## Deprecated Patterns

1. **`getAllEntries()` method (lines 324-335)**: Marked as `@deprecated` in favor of `getAllEntriesPaginated()` but still called in IPC handler `history:getAll`. Should create migration path to paginated version.

2. **`getEntriesByProjectPath()` method (lines 358-370)**: Marked as `@deprecated` in favor of `getEntriesByProjectPathPaginated()` but still called in IPC handler. Should transition to paginated version.

3. **Synchronous file operations throughout**: All file operations use synchronous `fs.*Sync` methods which can block the Node.js event loop:
   - `fs.existsSync()` - 18 occurrences
   - `fs.readFileSync()` - 6 occurrences
   - `fs.writeFileSync()` - 5 occurrences
   - `fs.mkdirSync()` - 2 occurrences
   - `fs.unlinkSync()` - 1 occurrence
   - `fs.readdirSync()` - 1 occurrence

   The main process should prefer async file operations to avoid blocking during heavy I/O.

## Duplication

1. **Major duplication with CLI storage.ts**: The CLI services file `src/cli/services/storage.ts` reimplements much of the same functionality:
   - `hasMigrated()` duplicated at storage.ts:97-100 (similar logic)
   - `getHistoryDir()` duplicated at storage.ts:105-107
   - `getSessionHistoryPath()` duplicated at storage.ts:112-115 (same as `getSessionFilePath`)
   - `readSessionHistory()` duplicated at storage.ts:120-131 (same as `getEntries`)
   - `listSessionsWithHistory()` duplicated at storage.ts:136-145 (identical logic)
   - `sortEntriesByTimestamp()` calls duplicated in both files

   Both files use the same shared constants from `shared/history.ts`, but the implementation logic is duplicated.

2. **Session file data structure creation duplicated (lines 197-202)**: The `HistoryFileData` object creation pattern appears twice in `addEntry()`:
   ```typescript
   data = { version: HISTORY_VERSION, sessionId, projectPath, entries: [] };
   ```

3. **File existence check + read pattern repeated**: The pattern of checking file existence and then reading is repeated 5 times throughout the file (getEntries, addEntry, deleteEntry, updateEntry, getHistoryFilePath).

## Code Smells

1. **No unit tests**: Despite being a critical data persistence component, there is no test file at `src/__tests__/main/history-manager.test.ts`. The storage.ts equivalent has tests, but HistoryManager does not.

2. **Missing retry logic for file operations**: If a write fails (e.g., disk full, permissions), the operation fails silently or logs an error without retry. No transactional safety for multi-file operations in migration.

3. **`updateSessionNameByClaudeSessionId` is expensive (lines 405-435)**: This method scans ALL history files to find entries matching an agentSessionId. With many sessions, this could be slow. No index or cache for agentSessionId lookups.

4. **Watcher event handling is naive (lines 466-480)**: The fs.watch callback doesn't debounce multiple rapid events. If a file is written multiple times quickly, multiple change notifications will fire.

5. **Magic string in `hasMigrated()` check**: The marker file name `'history-migrated.json'` is used but not extracted to a constant, while the legacy file name is stored in a property.

6. **No validation of HistoryFileData structure on read**: When reading JSON files, there's no schema validation. Corrupted files could cause runtime errors beyond the basic try-catch.

## Type Safety Issues

1. **`watcher: fs.FSWatcher | null` (line 42)**: The null union type requires null checks throughout. Consider using a separate `isWatching` boolean flag.

2. **Non-null assertion used (line 116)**: `entriesBySession.get(sessionId)!.push(entry)` - the `!` assertion is safe here due to the previous `has()` check, but could use optional chaining pattern instead.

3. **Implicit any in catch blocks**: Multiple catch blocks don't type the error:
   - Line 81: `catch {` - no error typed
   - Line 197: `catch {` - no error typed
   - Line 248: `catch {` - no error typed
   - Line 279: `catch {` - no error typed

   These should use `catch (error: unknown)` and handle appropriately.

4. **Loose return type on `getAllEntries()`**: Returns `HistoryEntry[]` but the internal sorting could theoretically fail on malformed entries without timestamp.

5. **`onExternalChange` callback not typed strictly (line 466)**: The callback signature could include more context (e.g., event type, full path).

## Recommended Refactoring

1. **Extract shared logic to reusable module (High priority)**
   Create a shared history file access module that both `HistoryManager` and `cli/services/storage.ts` can use. This would eliminate the duplication of file reading/writing logic.

2. **Add unit tests for HistoryManager (High priority)**
   The CLI storage.ts has tests at `src/__tests__/cli/services/storage.test.ts`. HistoryManager needs equivalent coverage for:
   - Migration scenarios
   - CRUD operations
   - Edge cases (corrupted files, missing files)
   - Watcher behavior

3. **Convert to async file operations (Medium priority)**
   Replace synchronous file operations with async versions using `fs/promises`:
   - `fs.promises.readFile()` instead of `readFileSync()`
   - `fs.promises.writeFile()` instead of `writeFileSync()`
   - This prevents blocking the main process event loop

4. **Remove deprecated methods or update callers (Medium priority)**
   Either remove `getAllEntries()` and `getEntriesByProjectPath()` after updating IPC handlers to use paginated versions, or remove the `@deprecated` tags if they need to stay.

5. **Remove unused public methods (Low priority)**
   - Make `hasMigrated()`, `getLegacyFilePath()`, and `getHistoryDir()` private or remove them
   - If kept for testing, add actual tests that use them

6. **Add debouncing to watcher (Low priority)**
   Use a debounce/throttle pattern to prevent rapid-fire change notifications when files are updated quickly.

7. **Add schema validation on read (Low priority)**
   Use Zod or similar to validate `HistoryFileData` structure when reading files to gracefully handle corrupted data.

## Estimated Impact

**Risk Level: Low-Medium**

The history manager handles non-critical user data (execution history). Refactoring has low risk because:
- History is supplementary data, not critical to app functionality
- Data loss would be annoying but not catastrophic
- The file format is well-documented in `shared/history.ts`

**Testing Considerations:**
- Need to add unit tests before making changes (currently none exist)
- Test migration path from legacy format
- Test concurrent read/write scenarios
- Test watcher behavior with rapid file changes
- Integration test with IPC handlers

**Performance Considerations:**
- Converting to async file operations will improve main process responsiveness
- The `updateSessionNameByClaudeSessionId` method scanning all files may need optimization for users with many sessions
