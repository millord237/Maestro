# Refactor Task 33: src/main/utils/execFile.ts

## Summary

This is an exemplary utility file at 46 lines - concise, focused, and well-documented. It provides the single safe command execution function `execFileNoThrow` used throughout the main process. The file has excellent test coverage (567-line test file). The main issues identified are a type safety problem with `exitCode` and minor duplication with CLI's `execFileSync` usage.

## Dead Code

None found.

- `execFileNoThrow` is imported and used in 8 production files (git.ts, agents.ts, system.ts, codex-session-storage.ts, agent-detector.ts, shellDetector.ts, cliDetection.ts)
- `ExecResult` interface is exported and used in test file
- `EXEC_MAX_BUFFER` constant is used by `execFileNoThrow`

## Deprecated Patterns

None found.

- Uses modern `promisify` pattern from Node.js util module
- Uses `execFile` instead of `exec` to prevent shell injection (security best practice)
- Follows async/await patterns correctly

## Duplication

**Minor Duplication with CLI:**

1. **execFileSync vs execFileNoThrow pattern** - `src/cli/services/batch-processor.ts` (lines 4, 54-80) uses `execFileSync` directly instead of importing `execFileNoThrow`:
   ```typescript
   // batch-processor.ts
   import { execFileSync } from 'child_process';

   function getGitBranch(cwd: string): string | undefined {
     try {
       const branch = execFileSync('git', ['rev-parse', '--abbrev-ref', 'HEAD'], {
         cwd,
         encoding: 'utf-8',
         stdio: ['pipe', 'pipe', 'pipe'],
       }).trim();
       return branch || undefined;
     } catch {
       return undefined;
     }
   }
   ```
   This is documented in `src/shared/gitUtils.ts` (lines 6-9) as intentional due to different environments (async main process vs sync CLI), but could share a synchronous version.

2. **Error handling pattern** - The try/catch with extracting `stdout`/`stderr`/`code` from error object is similar between `execFileNoThrow` and the CLI usage, just synchronous vs asynchronous.

## Code Smells

**Bug: `error.code || 1` fails for exit code 0:**

File: `src/main/utils/execFile.ts:43`
```typescript
exitCode: error.code || 1,
```

The test file explicitly documents this bug at line 520-524:
```typescript
it('should handle error code 0 (falsy but valid)', async () => {
  // Due to || operator, 0 is falsy so it defaults to 1
  expect(result.exitCode).toBe(1);
});
```

While rare, an error with code 0 would be incorrectly reported as exit code 1. Should use nullish coalescing:
```typescript
exitCode: error.code ?? 1,
```

## Type Safety Issues

**Critical: ExecResult.exitCode type mismatch:**

File: `src/main/utils/execFile.ts:12`
```typescript
export interface ExecResult {
  stdout: string;
  stderr: string;
  exitCode: number;  // <-- Declared as number
}
```

But `error.code` from Node.js can be:
- A numeric exit code (0, 1, 128, etc.)
- A string error code like `'ENOENT'`, `'EPERM'`, `'EACCES'`, etc.

The test file proves this at lines 332 and 354:
```typescript
expect(result.exitCode).toBe('ENOENT');  // String, not number!
expect(result.exitCode).toBe('EPERM');   // String, not number!
```

The interface should be:
```typescript
exitCode: number | string;
```

Or alternatively, normalize string codes to numeric values (e.g., ENOENT = -2, EPERM = -1).

## Recommended Refactoring

1. **Fix exitCode type (High):** Change `exitCode: number` to `exitCode: number | string` in `ExecResult` interface to match actual behavior. This is a breaking type change that may require updates to callers.

2. **Use nullish coalescing (High):** Replace `error.code || 1` with `error.code ?? 1` to correctly handle exit code 0.

3. **Consider sync version for CLI (Low):** Add `execFileSyncNoThrow` export for CLI to use, avoiding duplication in batch-processor.ts. This would unify error handling patterns.

4. **Add JSDoc for exitCode (Low):** Document that `exitCode` can be a string for system errors like ENOENT.

## Estimated Impact

**Risk Level: Low**

- File is small and well-tested (567-line test file covers edge cases)
- Type change to `exitCode` may require minor updates to callers checking `exitCode === 0` vs `exitCode !== 0`
- No data migration needed
- Changes can be tested locally before deployment

**Testing Considerations:**

- Existing test suite is comprehensive and should catch regressions
- After type change, run `npm run typecheck` to find callers that need updates
- Verify error code handling for ENOENT/EPERM scenarios still works
